rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================================
    // HELPERS
    // ============================================================================

    function isSignedIn() {
      return request.auth != null;
    }

    function userDoc(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }

    function userExists(uid) {
      return exists(/databases/$(database)/documents/users/$(uid));
    }

    function isEmailVerified() {
      return isSignedIn() &&
        userExists(request.auth.uid) &&
        userDoc(request.auth.uid).data.emailVerified == true;
    }

    function isAdmin() {
      return isSignedIn() &&
        userExists(request.auth.uid) &&
        userDoc(request.auth.uid).data.role == 'admin';
    }

    function isApprovedCommissioner() {
      return isSignedIn() &&
        userExists(request.auth.uid) &&
        userDoc(request.auth.uid).data.isApprovedCommissioner == true;
    }

    function getUserData() {
      return userDoc(request.auth.uid).data;
    }

    // Check if user is host of a league
    function isLeagueHost(leagueId) {
      let league = get(/databases/$(database)/documents/leagues/$(leagueId)).data;
      return request.auth.uid == league.hostUserId;
    }

    // Check if user is host or manager of a league
    function isLeagueManager(leagueId) {
      let league = get(/databases/$(database)/documents/leagues/$(leagueId)).data;
      return request.auth.uid == league.hostUserId ||
        (league.managerIds != null && request.auth.uid in league.managerIds);
    }

    // Check if user is a member of a league
    function isLeagueMember(leagueId) {
      return exists(/databases/$(database)/documents/leagues/$(leagueId)/members/$(request.auth.uid));
    }

    // ============================================================================
    // RATE LIMIT HELPERS
    // ============================================================================

    function canPost() {
      let u = getUserData();
      return !('lastPostTime' in u) ||
        u.lastPostTime == null ||
        u.lastPostTime < request.time - duration.value(30, 's');
    }

    function canComment() {
      let u = getUserData();
      return !('lastCommentTime' in u) ||
        u.lastCommentTime == null ||
        u.lastCommentTime < request.time - duration.value(5, 's');
    }

    function canMessage() {
      let u = getUserData();
      return !('lastMessageTime' in u) ||
        u.lastMessageTime == null ||
        u.lastMessageTime < request.time - duration.value(1, 's');
    }

    function canScore() {
      let u = getUserData();
      return !('lastScoreTime' in u) ||
        u.lastScoreTime == null ||
        u.lastScoreTime < request.time - duration.value(60, 's');
    }

    // ============================================================================
    // COLLECTION GROUP QUERIES
    // ============================================================================

    // Allows collection group queries on 'members' subcollection across all leagues
    // Used by: leagues/index.tsx to check if user is member of ANY league
    match /{path=**}/members/{memberId} {
      allow read, list: if isSignedIn();
    }

    // ============================================================================
    // USERS
    // ============================================================================

    match /users/{userId} {
      allow read, list: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;

      allow update: if isSignedIn() &&
        (
          request.auth.uid == userId ||
          isAdmin() ||
          request.resource.data.diff(resource.data)
            .affectedKeys().hasOnly(['partners'])
        );

      allow delete: if isAdmin();

      // ✅ Handicap History - readable by any signed-in user, only Cloud Functions write
      match /handicapHistory/{historyId} {
        allow read: if isSignedIn();
        allow write: if false;
      }
    }

    // ============================================================================
    // THOUGHTS (CLUBHOUSE POSTS)
    // ============================================================================

    match /thoughts/{thoughtId} {
      allow read, list: if true;

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        canPost() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.content.size() <= 280;

      // ✅ FIXED: Allow owner/admin full update, OR any signed-in user can update engagement fields
      allow update: if isSignedIn() &&
        (
          request.auth.uid == resource.data.userId ||
          isAdmin() ||
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['likes', 'likedBy', 'comments', 'lastActivityAt', 'engagementScore', 'viewCount'])
        );

      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());

      // COMMENTS SUBCOLLECTION
      match /comments/{commentId} {
        allow read, list: if true;
        allow create, update, delete: if isSignedIn();
      }
    }

    // ============================================================================
    // POLL VOTES
    // ============================================================================
    // Separate collection for poll votes to avoid race conditions on the thought doc.
    // Cloud Functions (Admin SDK) handle incrementing vote counts on the thought's
    // poll.options[].votes, poll.totalVotes, and poll.options[].voterIds atomically.
    //
    // Document ID convention: {thoughtId}_{userId} (ensures one vote per user per poll)
    //
    // Document shape:
    // {
    //   thoughtId: string,       // the poll thought being voted on
    //   userId: string,          // the voter
    //   optionIndex: number,     // which option they chose (0-based)
    //   optionText: string,      // denormalized for easy reads
    //   displayName: string,     // voter's display name (denormalized)
    //   userAvatar: string|null, // voter's avatar (denormalized)
    //   createdAt: timestamp,
    // }

    match /poll_votes/{voteId} {
      // Anyone signed in can read votes (needed to check if user already voted)
      allow read, list: if isSignedIn();

      // ✅ Create: User can vote once per poll
      // - voteId must be {thoughtId}_{userId} to enforce uniqueness
      // - userId must match authenticated user
      // - Must reference a valid thought
      // - Must include required fields
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.thoughtId is string &&
        request.resource.data.optionIndex is int &&
        request.resource.data.optionIndex >= 0 &&
        voteId == request.resource.data.thoughtId + '_' + request.auth.uid;

      // ✅ Update: User can change their vote (same field constraints)
      allow update: if isSignedIn() &&
        request.auth.uid == resource.data.userId &&
        // Can only change the option selected and timestamp
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['optionIndex', 'optionText', 'updatedAt']);

      // ✅ Delete: User can remove their vote, admin can remove any
      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // COMMENTS (TOP-LEVEL - FOR CLOUD FUNCTION TRIGGERS)
    // ============================================================================

    match /comments/{commentId} {
      allow read, list: if isSignedIn();

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.content.size() <= 500 &&
        request.resource.data.postId is string &&
        request.resource.data.postAuthorId is string;

      // ✅ FIXED: Allow engagement field updates for comment likes
      allow update: if isSignedIn() &&
        (
          request.auth.uid == resource.data.userId ||
          isAdmin() ||
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['likes', 'likedBy'])
        );

      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // LIKES (POST LIKES)
    // ============================================================================

    match /likes/{likeId} {
      allow read, list: if isSignedIn();

      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.postId is string &&
        request.resource.data.postAuthorId is string;

      allow delete: if isSignedIn() &&
        request.auth.uid == resource.data.userId;

      allow update: if false;
    }

    // ============================================================================
    // COMMENT LIKES (FOR CLOUD FUNCTION TRIGGERS)
    // ============================================================================

    match /comment_likes/{likeId} {
      allow read, list: if isSignedIn();

      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.commentId is string &&
        request.resource.data.commentAuthorId is string;

      allow delete: if isSignedIn() &&
        request.auth.uid == resource.data.userId;

      allow update: if false;
    }

    // ============================================================================
    // SHARES (FOR CLOUD FUNCTION TRIGGERS - FUTURE)
    // ============================================================================

    match /shares/{shareId} {
      allow read, list: if isSignedIn();

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid;

      allow delete: if isSignedIn() &&
        request.auth.uid == resource.data.userId;

      allow update: if false;
    }

    // ============================================================================
    // SCORES
    // ============================================================================

    match /scores/{scoreId} {
      allow read, list: if true;

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        canScore() &&
        request.resource.data.userId == request.auth.uid;

      allow update, delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // LEADERBOARDS
    // ============================================================================

    match /leaderboards/{leaderboardId} {
      allow read, list: if true;
      allow create, update: if isSignedIn();
      allow delete: if isAdmin();
    }

    // ============================================================================
    // TOURNAMENTS (PGA TOUR DATA)
    // ============================================================================

    match /tournaments/{tournamentId} {
      // Anyone can read tournament data (public info)
      allow read, list: if true;
      
      // Only Cloud Functions can write (via Admin SDK)
      allow create, update, delete: if false;
    }

    // ============================================================================
    // TOURNAMENT LEADERBOARDS (LIVE LEADERBOARD DATA)
    // ============================================================================

    match /tournamentLeaderboards/{leaderboardId} {
      // Anyone can read leaderboard data (public info)
      allow read, list: if true;
      
      // Only Cloud Functions can write (via Admin SDK)
      allow create, update, delete: if false;
    }

    // ============================================================================
    // TOURNAMENT CHATS (LIVE CHAT DURING TOURNAMENTS)
    // ============================================================================

    // Pattern: tournamentChats_2026_006_live or tournamentChats_2026_006_onpremise
    match /{chatCollection}/{messageId} {
      // Only match tournament chat collections
      allow read, list: if isSignedIn() && 
        chatCollection.matches('tournamentChats_.*');

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        chatCollection.matches('tournamentChats_.*') &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.content.size() <= 280;

      // Allow users to delete their own messages, admins can delete any
      allow delete: if isSignedIn() &&
        chatCollection.matches('tournamentChats_.*') &&
        (request.auth.uid == resource.data.userId || isAdmin());

      // No updates to chat messages
      allow update: if false;
    }

    // ============================================================================
    // COURSES / CLUBS
    // ============================================================================

    match /courses/{courseId} {
      allow read, list: if true;
      allow create, update: if isSignedIn();
      allow delete: if isAdmin();
    }

    match /clubs/{clubId} {
      allow read, list: if true;

      allow create: if isSignedIn() && isEmailVerified();

      allow update, delete: if isSignedIn() &&
        (request.auth.uid == resource.data.ownerId || isAdmin());
    }

    // ============================================================================
    // PARTNER REQUESTS
    // ============================================================================

    match /partnerRequests/{requestId} {
      allow read, list: if isSignedIn() &&
        (
          request.auth.uid == resource.data.fromUserId ||
          request.auth.uid == resource.data.toUserId ||
          isAdmin()
        );

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.fromUserId == request.auth.uid;

      allow update, delete: if isSignedIn() &&
        (
          request.auth.uid == resource.data.fromUserId ||
          request.auth.uid == resource.data.toUserId ||
          isAdmin()
        );
    }

    // ============================================================================
    // PARTNERS
    // ============================================================================

    match /partners/{partnerId} {
      allow read, list: if isSignedIn();

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        (
          request.auth.uid == request.resource.data.user1Id ||
          request.auth.uid == request.resource.data.user2Id
        );

      allow update, delete: if isSignedIn() &&
        (
          request.auth.uid == resource.data.user1Id ||
          request.auth.uid == resource.data.user2Id ||
          isAdmin()
        );
    }

    // ============================================================================
    // NOTIFICATIONS
    // ============================================================================

    match /notifications/{notificationId} {
      allow read, list: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());

      allow create: if isAdmin();

      allow update, delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // THREADS (MESSAGING - 1:1 AND GROUP CHATS)
    // ============================================================================

    match /threads/{threadId} {

      // ✅ Check if user ID appears in the thread document ID (for 1:1 chats with deterministic IDs)
      function isUserInThreadId() {
        return request.auth != null &&
          threadId.matches('.*' + request.auth.uid + '.*');
      }

      // ✅ Check if user is in participants array (for both 1:1 and group chats)
      function isParticipant() {
        return request.auth != null &&
          resource.data.participants.hasAny([request.auth.uid]);
      }

      // ✅ Check if user will be a participant in new document (for create)
      function willBeParticipant() {
        return request.auth != null &&
          request.resource.data.participants.hasAny([request.auth.uid]);
      }

      // List threads - filter by participant on client side
      allow list: if isSignedIn();

      // Read thread if user is participant OR user ID is in thread ID (backward compat)
      allow read: if isSignedIn() && 
        (isParticipant() || isUserInThreadId());

      // ✅ CREATE THREAD:
      // - 1:1 chat: User ID must be in thread document ID AND in participants
      // - Group chat: User must be in participants array with isGroup=true and 3+ participants
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.participants is list &&
        willBeParticipant() &&
        (
          // 1:1 chat: deterministic ID containing user's UID (e.g., "userA_userB")
          isUserInThreadId() ||
          // Group chat: Firestore-generated ID, must have isGroup flag and 3+ participants
          (
            request.resource.data.isGroup == true && 
            request.resource.data.participants.size() >= 3 &&
            request.resource.data.createdBy == request.auth.uid
          )
        );

      // Delete thread - only participants or admin
      allow delete: if isAdmin() || isParticipant();

      // ✅ UPDATE THREAD:
      // - Participants array CANNOT change after creation (immutable)
      // - Only specific metadata fields can be updated
      // - Users can only modify their own unreadCount entry
      allow update: if isSignedIn() &&
        isParticipant() &&
        // Participants array cannot be modified after creation
        request.resource.data.participants == resource.data.participants &&
        // isGroup flag cannot be changed after creation
        (
          !('isGroup' in resource.data) || 
          request.resource.data.isGroup == resource.data.isGroup
        ) &&
        // createdBy cannot be changed after creation
        (
          !('createdBy' in resource.data) || 
          request.resource.data.createdBy == resource.data.createdBy
        ) &&
        // Only allow specific fields to be updated
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'lastMessage',
          'lastSenderId',
          'lastMessageAt',
          'unreadCount',
          'participantNames',
          'participantAvatars',
          'updatedAt',
          'archivedBy',
          'deletedBy',
          'groupName'  // ✅ NEW: Allow group name to be updated by participants
        ]) &&
        // Unread count: users can only modify their own entry (or admin can modify any)
        (
          !('unreadCount' in request.resource.data) ||
          isAdmin() ||
          request.resource.data.unreadCount
            .diff(resource.data.unreadCount)
            .affectedKeys().hasOnly([request.auth.uid])
        );

      // ============================================================================
      // THREAD MESSAGES (1:1 AND GROUP)
      // ============================================================================
      match /messages/{messageId} {

        // Check if user ID is in parent thread ID (for 1:1 chats)
        function isUserInParentThreadId() {
          return request.auth != null &&
            threadId.matches('.*' + request.auth.uid + '.*');
        }

        // ✅ Check if user is participant in parent thread (for group chats)
        // Only call this when the thread document exists
        function isParentThreadParticipant() {
          return request.auth != null &&
            exists(/databases/$(database)/documents/threads/$(threadId)) &&
            get(/databases/$(database)/documents/threads/$(threadId)).data.participants.hasAny([request.auth.uid]);
        }

        // ✅ List messages if user has access to thread (1:1 OR group)
        allow list: if isSignedIn() && 
          (isUserInParentThreadId() || isParentThreadParticipant());

        // ✅ Read message if user is sender, receiver, OR thread participant
        allow read: if request.auth != null &&
          (
            resource.data.senderId == request.auth.uid ||
            resource.data.receiverId == request.auth.uid ||
            isUserInParentThreadId() ||
            isParentThreadParticipant()
          );

        // ✅ Create message if user has thread access and is the sender
        // - 1:1: User ID is in thread ID (works even if thread doc doesn't exist yet)
        // - Group: User is participant in existing thread doc
        allow create: if isSignedIn() &&
          isEmailVerified() &&
          canMessage() &&
          (isUserInParentThreadId() || isParentThreadParticipant()) &&
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.content.size() <= 1000;

        // Update message - only specific fields by specific users
        allow update: if isSignedIn() &&
          (
            // Receiver can mark as read (1:1 chats only)
            (request.auth.uid == resource.data.receiverId &&
             request.resource.data.diff(resource.data)
               .affectedKeys().hasOnly(['read', 'readAt']))
            ||
            // Sender can edit content
            (request.auth.uid == resource.data.senderId &&
             request.resource.data.diff(resource.data)
               .affectedKeys().hasOnly(['content', 'edited', 'editedAt']))
          );

        // Delete message if sender or admin
        allow delete: if isSignedIn() &&
          (request.auth.uid == resource.data.senderId || isAdmin());
      }
    }

    // ============================================================================
    // MESSAGES (TOP-LEVEL - FOR CLOUD FUNCTION TRIGGERS)
    // ============================================================================

    match /messages/{messageId} {
      allow read, list: if isSignedIn() &&
        (
          request.auth.uid == resource.data.senderId ||
          request.auth.uid == resource.data.receiverId ||
          isAdmin()
        );

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.senderId == request.auth.uid;

      allow update, delete: if isSignedIn() &&
        (request.auth.uid == resource.data.senderId || isAdmin());
    }

    // ============================================================================
    // HOLE-IN-ONE VERIFICATION
    // ✅ UPDATED: Any signed-in user can read (needed for feed HIO card)
    // ============================================================================

    match /hole_in_ones/{holeInOneId} {
      allow read, list: if isSignedIn();

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid;

      allow update: if isSignedIn() &&
        (
          request.auth.uid == resource.data.userId ||
          request.auth.uid == resource.data.verifierId ||
          isAdmin()
        );

      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // COURSE MEMBERSHIPS
    // ============================================================================

    match /course_memberships/{membershipId} {
      allow read, list: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid;

      allow update: if isAdmin();

      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // VERIFICATION REQUESTS (PGA/COURSE)
    // ============================================================================

    match /verification_requests/{requestId} {
      allow read, list: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());

      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      allow update: if isAdmin();

      allow delete: if isAdmin();
    }

    // ============================================================================
    // COURSE LEADERS
    // ============================================================================

    match /course_leaders/{courseId} {
      allow read, list: if true;
      
      allow create, update: if isSignedIn() && isEmailVerified();
      
      allow delete: if isAdmin();
    }

    // ============================================================================
    // REPORTS (Posts, Comments, Users, Messages)
    // ============================================================================

    match /reports/{reportId} {
      // Users can read their own reports, admins can read all
      allow read: if isSignedIn() &&
        (request.auth.uid == resource.data.reporterId || isAdmin());

      // List: Allow signed-in users (client-side filtering required for own reports)
      // Admins can list all
      allow list: if isSignedIn();

      // ✅ Any verified user can report content
      // Fields: reporterId, reporterName, postId, postAuthorId, postAuthorName, 
      //         postContent, category, details, status, createdAt
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.reporterId == request.auth.uid &&
        request.resource.data.postId is string &&
        request.resource.data.postAuthorId is string &&
        request.resource.data.category is string &&
        request.resource.data.status == "pending";

      // Only admins can update (mark reviewed, take action) or delete
      allow update, delete: if isAdmin();
    }

    // ============================================================================
    // PUSH TOKENS
    // ============================================================================

    match /push_tokens/{tokenId} {
      allow read, list: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());

      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // LEAGUES
    // ============================================================================

    match /leagues/{leagueId} {
      allow read, list: if true;

      // ✅ Approved commissioners can create leagues (they become the host)
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        (isApprovedCommissioner() || isAdmin()) &&
        request.resource.data.hostUserId == request.auth.uid;

      // ✅ Host, managers, or admin can update league settings
      allow update: if isSignedIn() &&
        (isLeagueManager(leagueId) || isAdmin());

      allow delete: if isAdmin();

      // ========================================================================
      // LEAGUE MEMBERS SUBCOLLECTION
      // ========================================================================
      match /members/{memberId} {
        allow read, list: if isSignedIn();

        // ✅ Users can add themselves OR host/manager can add members
        allow create: if isSignedIn() &&
          isEmailVerified() &&
          (
            memberId == request.auth.uid ||
            isLeagueManager(leagueId)
          );

        // ✅ Member can update own data, host/manager can update any member
        allow update: if isSignedIn() &&
          (
            memberId == request.auth.uid ||
            isLeagueManager(leagueId) ||
            isAdmin()
          );

        // ✅ Member can leave, host/manager can remove members
        allow delete: if isSignedIn() &&
          (
            memberId == request.auth.uid ||
            isLeagueManager(leagueId) ||
            isAdmin()
          );
      }

      // ========================================================================
      // LEAGUE INVITES SUBCOLLECTION (invite users to join)
      // ========================================================================
      match /invites/{inviteId} {
        allow read, list: if isSignedIn();

        // ✅ Host/manager can create invites
        allow create: if isSignedIn() &&
          isLeagueManager(leagueId) &&
          request.resource.data.inviterId == request.auth.uid &&
          request.resource.data.status == "pending";

        // ✅ Invited user can accept/decline, host/manager can update
        allow update: if isSignedIn() &&
          (
            request.auth.uid == resource.data.inviteeId ||
            isLeagueManager(leagueId)
          );

        // ✅ Host/manager can delete invites, invited user can delete their own
        allow delete: if isSignedIn() &&
          (
            request.auth.uid == resource.data.inviteeId ||
            isLeagueManager(leagueId) ||
            isAdmin()
          );
      }

      // ========================================================================
      // LEAGUE TEAMS SUBCOLLECTION (for 2v2 format)
      // ========================================================================
      match /teams/{teamId} {
        allow read, list: if isSignedIn();

        // Only host/manager can create/update/delete teams
        allow create, update, delete: if isSignedIn() &&
          (isLeagueManager(leagueId) || isAdmin());
      }

      // ========================================================================
      // LEAGUE TEAM EDIT REQUESTS SUBCOLLECTION
      // ========================================================================
      match /team_edit_requests/{requestId} {
        allow read, list: if isSignedIn();

        // Team members can create requests for their team
        allow create: if isSignedIn() &&
          isEmailVerified() &&
          request.resource.data.requesterId == request.auth.uid &&
          request.resource.data.status == "pending";

        // Only host/manager can approve/reject
        allow update: if isSignedIn() &&
          (isLeagueManager(leagueId) || isAdmin());

        // Requester can delete pending, host/manager can delete any
        allow delete: if isSignedIn() &&
          (
            (request.auth.uid == resource.data.requesterId && resource.data.status == "pending") ||
            isLeagueManager(leagueId) ||
            isAdmin()
          );
      }

      // ========================================================================
      // LEAGUE SCORES SUBCOLLECTION
      // ========================================================================
      match /scores/{scoreId} {
        allow read, list: if isSignedIn();

        allow create: if isSignedIn() &&
          isEmailVerified() &&
          request.resource.data.userId == request.auth.uid;

        allow update, delete: if isSignedIn() &&
          (
            request.auth.uid == resource.data.userId ||
            isLeagueManager(leagueId) ||
            isAdmin()
          );
      }

      // ========================================================================
      // LEAGUE ANNOUNCEMENTS SUBCOLLECTION
      // ========================================================================
      match /announcements/{announcementId} {
        allow read, list: if isSignedIn();

        // ✅ Only host/manager can create announcements
        allow create: if isSignedIn() &&
          isLeagueManager(leagueId) &&
          request.resource.data.authorId == request.auth.uid;

        // ✅ Only host/manager can update/delete announcements
        allow update, delete: if isSignedIn() &&
          (isLeagueManager(leagueId) || isAdmin());
      }

      // ========================================================================
      // LEAGUE WEEK RESULTS SUBCOLLECTION
      // ========================================================================
      match /week_results/{resultId} {
        // ✅ League members can read week results
        allow read, list: if isSignedIn();

        // ✅ Only Cloud Functions write these (via Admin SDK)
        // Host/manager can manually create/update if needed
        allow create, update: if isSignedIn() &&
          (isLeagueManager(leagueId) || isAdmin());

        allow delete: if isAdmin();
      }

      // ========================================================================
      // LEAGUE MANAGER INVITES SUBCOLLECTION
      // ========================================================================
      match /manager_invites/{inviteId} {
        allow read, list: if isSignedIn();

        // Only host can invite managers
        allow create: if isSignedIn() &&
          isLeagueHost(leagueId);

        // Invited user can accept/decline, host can cancel
        allow update: if isSignedIn() &&
          (
            request.auth.uid == resource.data.inviteeId ||
            isLeagueHost(leagueId)
          );

        // Host can delete invites
        allow delete: if isSignedIn() &&
          (isLeagueHost(leagueId) || isAdmin());
      }
    }

    // ============================================================================
    // LEAGUE APPLICATIONS (COMMISSIONER APPLICATIONS)
    // ============================================================================

    match /league_applications/{applicationId} {
      allow read, list: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());

      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid;

      allow update: if isAdmin();

      allow delete: if isSignedIn() &&
        (request.auth.uid == resource.data.userId || isAdmin());
    }

    // ============================================================================
    // LEAGUE JOIN REQUESTS (MEMBER JOIN REQUESTS)
    // ============================================================================

    match /league_join_requests/{requestId} {
      // User can read their own requests, host/manager can read requests for their league
      allow read: if isSignedIn() &&
        (
          request.auth.uid == resource.data.userId ||
          isLeagueManager(resource.data.leagueId) ||
          isAdmin()
        );

      // List - client-side filtering required
      allow list: if isSignedIn();

      // User can create request to join (must be for themselves)
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.leagueId is string &&
        request.resource.data.status == "pending";

      // Host, manager, or admin can update (approve/reject)
      allow update: if isSignedIn() &&
        (
          isLeagueManager(resource.data.leagueId) ||
          isAdmin()
        );

      // User can delete their own pending request, host/manager/admin can delete any
      allow delete: if isSignedIn() &&
        (
          (request.auth.uid == resource.data.userId && resource.data.status == "pending") ||
          isLeagueManager(resource.data.leagueId) ||
          isAdmin()
        );
    }

    // ============================================================================
    // LEAGUE INVITES (MEMBER-TO-MEMBER INVITES)
    // ============================================================================

    match /league_invites/{inviteId} {
      // Read: Inviter, invitee, league managers, or admin
      allow read: if isSignedIn() &&
        (
          request.auth.uid == resource.data.invitedByUserId ||
          request.auth.uid == resource.data.invitedUserId ||
          isLeagueManager(resource.data.leagueId) ||
          isAdmin()
        );

      // List: Signed-in users (client-side filtering required)
      allow list: if isSignedIn();

      // Create: Any league member can invite any user
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        isLeagueMember(request.resource.data.leagueId) &&
        request.resource.data.invitedByUserId == request.auth.uid &&
        request.resource.data.invitedUserId is string &&
        request.resource.data.leagueId is string &&
        request.resource.data.status == "pending";

      // Update: Invitee can accept/decline, league managers can update
      allow update: if isSignedIn() &&
        (
          // Invitee can only change status
          (
            request.auth.uid == resource.data.invitedUserId &&
            request.resource.data.diff(resource.data).affectedKeys()
              .hasOnly(['status', 'updatedAt'])
          ) ||
          isLeagueManager(resource.data.leagueId) ||
          isAdmin()
        );

      // Delete: Inviter can cancel, invitee can delete, managers can delete
      allow delete: if isSignedIn() &&
        (
          request.auth.uid == resource.data.invitedByUserId ||
          request.auth.uid == resource.data.invitedUserId ||
          isLeagueManager(resource.data.leagueId) ||
          isAdmin()
        );
    }

    // ============================================================================
    // CHALLENGES
    // ============================================================================

    match /challenges/{challengeId} {
      allow read, list: if isSignedIn();

      // Only Cloud Functions write challenge docs (via Admin SDK)
      allow create, update, delete: if false;

      // Participants subcollection
      match /participants/{userId} {
        allow read: if isSignedIn();

        // Users can register themselves
        allow create: if isSignedIn() &&
          isEmailVerified() &&
          userId == request.auth.uid;

        // Users can update their own progress, Cloud Functions also update
        allow update: if isSignedIn() &&
          userId == request.auth.uid;

        // Users can deregister themselves
        allow delete: if isSignedIn() &&
          userId == request.auth.uid;
      }

      // DTP courses subcollection
      match /courses/{courseId} {
        allow read, list: if isSignedIn();

        // Only Cloud Functions write (via Admin SDK)
        allow create, update, delete: if false;
      }
    }

    // ============================================================================
    // FEED ACTIVITY (for feed insert cards, TTL auto-deletes after 7 days)
    // ✅ NEW: Top-level collection for "From the Field" activity carousel
    // ============================================================================

    match /feedActivity/{docId} {
      allow read, list: if isSignedIn();

      // Only Cloud Functions write (via Admin SDK)
      allow create, update, delete: if false;
    }

    // ============================================================================
    // DEFAULT DENY
    // ============================================================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}









